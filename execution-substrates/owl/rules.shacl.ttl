@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix erb: <http://example.org/erb#> .

# === Shape with rules for LanguageCandidates ===
erb:LanguageCandidatesShape a sh:NodeShape ;
    sh:targetClass erb:LanguageCandidates ;
    sh:rule [
        a sh:SPARQLRule ;
        rdfs:label "rule_LanguageCandidates_HasGrammar" ;
        sh:prefixes erb: ;
        sh:construct """
            PREFIX erb: <http://example.org/erb#>
            PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
            CONSTRUCT {
                $this erb:hasGrammar ?_result .
            }
            WHERE {
    $this a erb:LanguageCandidates .
    OPTIONAL { $this erb:hasSyntax ?has_syntax . }
                BIND((?has_syntax = true) AS ?_result)
            }
        """ ;
    ] ;
    sh:rule [
        a sh:SPARQLRule ;
        rdfs:label "rule_LanguageCandidates_Question" ;
        sh:prefixes erb: ;
        sh:construct """
            PREFIX erb: <http://example.org/erb#>
            PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
            CONSTRUCT {
                $this erb:question ?_result .
            }
            WHERE {
    $this a erb:LanguageCandidates .
    OPTIONAL { $this erb:name ?name . }
                BIND(CONCAT("Is ", ?name, " a language?") AS ?_result)
            }
        """ ;
    ] ;
    sh:rule [
        a sh:SPARQLRule ;
        rdfs:label "rule_LanguageCandidates_PredictedAnswer" ;
        sh:prefixes erb: ;
        sh:construct """
            PREFIX erb: <http://example.org/erb#>
            PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
            CONSTRUCT {
                $this erb:predictedAnswer ?_result .
            }
            WHERE {
    $this a erb:LanguageCandidates .
    OPTIONAL { $this erb:canBeHeld ?can_be_held . }
    OPTIONAL { $this erb:hasIdentity ?has_identity . }
    OPTIONAL { $this erb:hasLinearDecodingPressure ?has_linear_decoding_pressure . }
    OPTIONAL { $this erb:hasSyntax ?has_syntax . }
    OPTIONAL { $this erb:isDescriptionOf ?is_description_of . }
    OPTIONAL { $this erb:isStableOntologyReference ?is_stable_ontology_reference . }
    OPTIONAL { $this erb:requiresParsing ?requires_parsing . }
    OPTIONAL { $this erb:resolvesToAnAST ?resolves_to_an_ast . }
                BIND((?has_syntax && ?requires_parsing && ?is_description_of && ?has_linear_decoding_pressure && ?resolves_to_an_ast && ?is_stable_ontology_reference && (!(?can_be_held)) && (!(?has_identity))) AS ?_result)
            }
        """ ;
    ] ;
    sh:rule [
        a sh:SPARQLRule ;
        rdfs:label "rule_LanguageCandidates_PredictionPredicates" ;
        sh:prefixes erb: ;
        sh:construct """
            PREFIX erb: <http://example.org/erb#>
            PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
            CONSTRUCT {
                $this erb:predictionPredicates ?_result .
            }
            WHERE {
    $this a erb:LanguageCandidates .
    OPTIONAL { $this erb:canBeHeld ?can_be_held . }
    OPTIONAL { $this erb:hasIdentity ?has_identity . }
    OPTIONAL { $this erb:hasLinearDecodingPressure ?has_linear_decoding_pressure . }
    OPTIONAL { $this erb:hasSyntax ?has_syntax . }
    OPTIONAL { $this erb:isDescriptionOf ?is_description_of . }
    OPTIONAL { $this erb:isStableOntologyReference ?is_stable_ontology_reference . }
    OPTIONAL { $this erb:requiresParsing ?requires_parsing . }
    OPTIONAL { $this erb:resolvesToAnAST ?resolves_to_an_ast . }
                BIND(CONCAT(IF(?has_syntax, "Has Syntax", "No Syntax"), ", ", IF(?requires_parsing, "Requires Parsing", "No Parsing Needed"), ", ", IF(?is_description_of, "Describes the thing", "Is the Thing"), ", ", IF(?has_linear_decoding_pressure, "Has Linear Decoding Pressure", "No Decoding Pressure"), ", ", IF(?resolves_to_an_ast, "Resolves to AST", "No AST"), ", ", IF(?is_stable_ontology_reference, "Is Stable Ontology", "Not \'Ontology\'"), ", ", IF(?can_be_held, "Can Be Held", "Can\'t Be Held"), " And ", IF(?has_identity, "Has Identity", "Has no Identity")) AS ?_result)
            }
        """ ;
    ] ;
    sh:rule [
        a sh:SPARQLRule ;
        rdfs:label "rule_LanguageCandidates_PredictionFail" ;
        sh:prefixes erb: ;
        sh:construct """
            PREFIX erb: <http://example.org/erb#>
            PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
            CONSTRUCT {
                $this erb:predictionFail ?_result .
            }
            WHERE {
    $this a erb:LanguageCandidates .
    OPTIONAL { $this erb:isLanguage ?is_language . }
    OPTIONAL { $this erb:isOpenClosedWorldConflicted ?is_open_closed_world_conflicted . }
    OPTIONAL { $this erb:name ?name . }
    OPTIONAL { $this erb:predictedAnswer ?predicted_answer . }
                BIND(CONCAT(IF((!((?predicted_answer = ?is_language))), CONCAT(?name, " ", IF(?predicted_answer, "Is", "Isn\'t"), " a Family Feud Language, but ", IF(?is_language, "Is", "Is Not"), " marked as a \'Language Candidate.\'"), ""), IF(?is_open_closed_world_conflicted, " - Open World vs. Closed World Conflict.", "")) AS ?_result)
            }
        """ ;
    ] ;
    sh:rule [
        a sh:SPARQLRule ;
        rdfs:label "rule_LanguageCandidates_IsDescriptionOf" ;
        sh:prefixes erb: ;
        sh:construct """
            PREFIX erb: <http://example.org/erb#>
            PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
            CONSTRUCT {
                $this erb:isDescriptionOf ?_result .
            }
            WHERE {
    $this a erb:LanguageCandidates .
    OPTIONAL { $this erb:distanceFromConcept ?distance_from_concept . }
                BIND((?distance_from_concept > 1) AS ?_result)
            }
        """ ;
    ] ;
    sh:rule [
        a sh:SPARQLRule ;
        rdfs:label "rule_LanguageCandidates_IsOpenClosedWorldConflicted" ;
        sh:prefixes erb: ;
        sh:construct """
            PREFIX erb: <http://example.org/erb#>
            PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
            CONSTRUCT {
                $this erb:isOpenClosedWorldConflicted ?_result .
            }
            WHERE {
    $this a erb:LanguageCandidates .
    OPTIONAL { $this erb:isClosedWorld ?is_closed_world . }
    OPTIONAL { $this erb:isOpenWorld ?is_open_world . }
                BIND((?is_open_world && ?is_closed_world) AS ?_result)
            }
        """ ;
    ] ;
    sh:rule [
        a sh:SPARQLRule ;
        rdfs:label "rule_LanguageCandidates_RelationshipToConcept" ;
        sh:prefixes erb: ;
        sh:construct """
            PREFIX erb: <http://example.org/erb#>
            PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
            CONSTRUCT {
                $this erb:relationshipToConcept ?_result .
            }
            WHERE {
    $this a erb:LanguageCandidates .
    OPTIONAL { $this erb:distanceFromConcept ?distance_from_concept . }
                BIND(IF((?distance_from_concept = 1), "IsMirrorOf", "IsDescriptionOf") AS ?_result)
            }
        """ ;
    ] .

# Generated 8 SHACL rules