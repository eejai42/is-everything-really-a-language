-- ============================================================================
-- CREATE FUNCTIONS - Calculation functions for lookup/calculated fields
-- ============================================================================
-- Generated by rulebook-to-postgres tool
-- ============================================================================

-- ============================================================================
-- LOOKUP FUNCTIONS
-- These functions perform lookups via foreign key relationships
-- ============================================================================


CREATE OR REPLACE FUNCTION calc_language_candidates_has_grammar(p_language_candidate_id TEXT)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN ((SELECT has_syntax FROM language_candidates WHERE language_candidate_id = p_language_candidate_id) = TRUE)::boolean;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;


CREATE OR REPLACE FUNCTION calc_language_candidates_question(p_language_candidate_id TEXT)
RETURNS TEXT AS $$
BEGIN
  RETURN ('Is " & (SELECT NULLIF(name, '''') FROM language_candidates WHERE language_candidate_id = p_language_candidate_id) & " a language?')::text;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;


CREATE OR REPLACE FUNCTION calc_language_candidates_predicted_answer(p_language_candidate_id TEXT)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN ((COALESCE((SELECT has_syntax FROM language_candidates WHERE language_candidate_id = p_language_candidate_id), FALSE) AND COALESCE((SELECT is_parsed FROM language_candidates WHERE language_candidate_id = p_language_candidate_id), FALSE) AND (calc_language_candidates_is_description_of(p_language_candidate_id) = 'true') AND COALESCE((SELECT has_linear_decoding_pressure FROM language_candidates WHERE language_candidate_id = p_language_candidate_id), FALSE) AND COALESCE((SELECT resolves_to_an_ast FROM language_candidates WHERE language_candidate_id = p_language_candidate_id), FALSE) AND COALESCE((SELECT is_stable_ontology_reference FROM language_candidates WHERE language_candidate_id = p_language_candidate_id), FALSE) AND NOT (COALESCE((SELECT can_be_held FROM language_candidates WHERE language_candidate_id = p_language_candidate_id), FALSE)) AND NOT (COALESCE((SELECT has_identity FROM language_candidates WHERE language_candidate_id = p_language_candidate_id), FALSE))))::boolean;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;


CREATE OR REPLACE FUNCTION calc_language_candidates_prediction_predicates(p_language_candidate_id TEXT)
RETURNS TEXT AS $$
BEGIN
  RETURN (CONCAT(CASE WHEN COALESCE((SELECT has_syntax FROM language_candidates WHERE language_candidate_id = p_language_candidate_id), FALSE) THEN 'Has Syntax' ELSE 'No Syntax' END, ' & ', CASE WHEN COALESCE((SELECT is_parsed FROM language_candidates WHERE language_candidate_id = p_language_candidate_id), FALSE) THEN 'Requires Parsing' ELSE 'No Parsing Neede' END, ' & ', CASE WHEN (calc_language_candidates_is_description_of(p_language_candidate_id) = 'true') THEN 'Describes the thing' ELSE 'Is the Thing' END, ' & ', CASE WHEN COALESCE((SELECT has_linear_decoding_pressure FROM language_candidates WHERE language_candidate_id = p_language_candidate_id), FALSE) THEN 'Has Linear Decoding Pressure' ELSE 'No Decoding Pressure' END, ' & ', CASE WHEN COALESCE((SELECT resolves_to_an_ast FROM language_candidates WHERE language_candidate_id = p_language_candidate_id), FALSE) THEN 'Resolves to AST' ELSE 'No AST' END, ', ', CASE WHEN COALESCE((SELECT is_stable_ontology_reference FROM language_candidates WHERE language_candidate_id = p_language_candidate_id), FALSE) THEN 'Is Stable Ontology' ELSE 'Not ''Ontology''' END, ' AND ', CASE WHEN COALESCE((SELECT can_be_held FROM language_candidates WHERE language_candidate_id = p_language_candidate_id), FALSE) THEN 'Can Be Held' ELSE 'Can''t Be Held' END, ', ', CASE WHEN COALESCE((SELECT has_identity FROM language_candidates WHERE language_candidate_id = p_language_candidate_id), FALSE) THEN 'Has Identity' ELSE 'Has no Identity' END))::text;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;


CREATE OR REPLACE FUNCTION calc_language_candidates_prediction_fail(p_language_candidate_id TEXT)
RETURNS TEXT AS $$
BEGIN
  RETURN (CONCAT(CASE WHEN NOT (calc_language_candidates_predicted_answer(p_language_candidate_id) = (SELECT is_language FROM language_candidates WHERE language_candidate_id = p_language_candidate_id)) THEN CONCAT((SELECT NULLIF(name, '') FROM language_candidates WHERE language_candidate_id = p_language_candidate_id), ' ', CASE WHEN (calc_language_candidates_predicted_answer(p_language_candidate_id) = 'true') THEN 'Is' ELSE 'Isn''t' END, ' a Family Feud Language, but ', CASE WHEN COALESCE((SELECT is_language FROM language_candidates WHERE language_candidate_id = p_language_candidate_id), FALSE) THEN 'Is' ELSE 'Is Not' END, ' marked as a ''Language Candidate.''') ELSE '' END, CASE WHEN (calc_language_candidates_is_open_closed_world_conflicted(p_language_candidate_id) = 'true') THEN ' - Open World vs. Closed World Conflict.' ELSE '' END))::text;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;


CREATE OR REPLACE FUNCTION calc_language_candidates_is_description_of(p_language_candidate_id TEXT)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN ((SELECT distance_from_concept FROM language_candidates WHERE language_candidate_id = p_language_candidate_id) > 1)::boolean;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;


CREATE OR REPLACE FUNCTION calc_language_candidates_is_open_closed_world_conflicted(p_language_candidate_id TEXT)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN ((COALESCE((SELECT is_open_world FROM language_candidates WHERE language_candidate_id = p_language_candidate_id), FALSE) AND COALESCE((SELECT is_closed_world FROM language_candidates WHERE language_candidate_id = p_language_candidate_id), FALSE)))::boolean;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;


CREATE OR REPLACE FUNCTION calc_language_candidates_relationship_to_concept(p_language_candidate_id TEXT)
RETURNS TEXT AS $$
BEGIN
  RETURN (CASE WHEN COALESCE((SELECT distance_from_concept FROM language_candidates WHERE language_candidate_id = p_language_candidate_id) = 1, FALSE) THEN 'IsMirrorOf' ELSE 'IsDescriptionOf' END)::text;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

-- ============================================================================
-- MANY-SIDE RELATIONSHIP FUNCTIONS
-- These functions aggregate child records for many-side relationships
-- ============================================================================

