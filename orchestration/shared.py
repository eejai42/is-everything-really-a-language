#!/usr/bin/env python3
"""
Shared functions for ERB language candidate generators.
All inject-into-*.py scripts use these common utilities.
"""

import json
import os
from pathlib import Path
from datetime import datetime


def get_rulebook_path():
    """Get the path to the effortless-rulebook.json file.

    Scripts run from /execution-substratrates/{candidate}/ so the rulebook
    is at ../../effortless-rulebook/effortless-rulebook.json
    """
    return Path("../../effortless-rulebook/effortless-rulebook.json")


def load_rulebook():
    """Load and parse the effortless-rulebook.json file."""
    rulebook_path = get_rulebook_path()

    if not rulebook_path.exists():
        raise FileNotFoundError(f"Rulebook not found at {rulebook_path}")

    with open(rulebook_path, 'r', encoding='utf-8') as f:
        return json.load(f)


def ensure_output_folder():
    """Ensure the current working directory exists (it should, since we run from there)."""
    cwd = Path.cwd()
    cwd.mkdir(parents=True, exist_ok=True)
    return cwd


def write_readme(candidate_name, description=None, technology=None):
    """Write a placeholder README.md for the language candidate.

    Args:
        candidate_name: Name of the target language/format (e.g., 'python', 'owl')
        description: Optional description, defaults to a placeholder message
        technology: Optional technology section explaining the format/language
    """
    output_folder = ensure_output_folder()
    readme_path = output_folder / "README.md"

    if description is None:
        description = f"Placeholder for {candidate_name} generation from the Effortless Rulebook."

    # Build technology section if provided
    technology_section = ""
    if technology:
        technology_section = f"\n## Technology\n\n{technology}\n"

    content = f"""# {candidate_name.title()} Language Candidate

{description}
{technology_section}
## Status

This is a placeholder generated by the ERB orchestration system.

## Source

Generated from: `effortless-rulebook/effortless-rulebook.json`

"""

    with open(readme_path, 'w', encoding='utf-8') as f:
        f.write(content)

    print(f"Created {readme_path}")
    return readme_path


def get_candidate_name_from_cwd():
    """Extract the candidate name from the current working directory.

    Assumes we're running from /execution-substratrates/{candidate}/
    """
    return Path.cwd().name


def clean_generated_files(generated_files: list, substrate_name: str = None):
    """Remove generated files from a substrate directory.

    Args:
        generated_files: List of filenames (relative to cwd) to remove
        substrate_name: Optional name for logging (defaults to cwd name)

    Returns:
        List of files that were successfully removed
    """
    if substrate_name is None:
        substrate_name = get_candidate_name_from_cwd()

    cwd = Path.cwd()
    removed = []

    print(f"Cleaning generated files for {substrate_name}...")

    for filename in generated_files:
        file_path = cwd / filename
        if file_path.exists():
            try:
                file_path.unlink()
                print(f"  Removed: {filename}")
                removed.append(filename)
            except Exception as e:
                print(f"  Failed to remove {filename}: {e}")
        else:
            print(f"  Skipped (not found): {filename}")

    if removed:
        print(f"Cleaned {len(removed)} file(s)")
    else:
        print("No files to clean")

    return removed


def handle_clean_arg(generated_files: list, description: str = None):
    """Check for --clean argument and perform cleanup if requested.

    Args:
        generated_files: List of filenames to remove when cleaning
        description: Optional description to display

    Returns:
        True if --clean was handled (script should exit), False otherwise
    """
    import sys

    if '--clean' in sys.argv:
        substrate_name = get_candidate_name_from_cwd()
        if description:
            print(f"\n{description}\n")
        print(f"=" * 60)
        print(f"CLEAN MODE: {substrate_name.upper()}")
        print(f"=" * 60)
        clean_generated_files(generated_files, substrate_name)
        return True

    return False


# =============================================================================
# ENTITY DISCOVERY FUNCTIONS
# =============================================================================
# These functions discover entities, schemas, and computed columns from the
# rulebook. They enable multi-entity processing across all substrates.
# =============================================================================

import re


def to_snake_case(name: str) -> str:
    """Convert PascalCase to snake_case: LanguageCandidates -> language_candidates"""
    s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
    return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()


def to_pascal_case(name: str) -> str:
    """Convert snake_case to PascalCase: language_candidates -> LanguageCandidates"""
    return ''.join(word.capitalize() for word in name.split('_'))


def discover_entities(rulebook: dict) -> list:
    """
    Discover all entities from the rulebook.
    Entities are top-level keys that have a 'schema' array.
    Returns list of entity names in PascalCase (as they appear in rulebook).
    """
    entities = []
    skip_keys = {'$schema', 'model_name', 'Description', '_meta'}

    for key, value in rulebook.items():
        if key in skip_keys:
            continue
        if isinstance(value, dict) and 'schema' in value:
            entities.append(key)

    return entities


def get_entity_schema(rulebook: dict, entity_name: str) -> list:
    """
    Get the schema array for an entity.
    Handles both PascalCase and snake_case entity names.
    """
    # Try direct lookup first
    if entity_name in rulebook:
        return rulebook[entity_name].get('schema', [])

    # Try converting from snake_case to PascalCase
    pascal_name = to_pascal_case(entity_name)
    if pascal_name in rulebook:
        return rulebook[pascal_name].get('schema', [])

    # Try converting from PascalCase to snake_case and look up
    snake_name = to_snake_case(entity_name)
    for key in rulebook:
        if to_snake_case(key) == snake_name:
            return rulebook[key].get('schema', [])

    return []


def get_entity_data(rulebook: dict, entity_name: str) -> list:
    """
    Get the data array for an entity.
    Handles both PascalCase and snake_case entity names.
    """
    # Try direct lookup first
    if entity_name in rulebook:
        return rulebook[entity_name].get('data', [])

    # Try converting from snake_case to PascalCase
    pascal_name = to_pascal_case(entity_name)
    if pascal_name in rulebook:
        return rulebook[pascal_name].get('data', [])

    # Try converting from PascalCase to snake_case and look up
    snake_name = to_snake_case(entity_name)
    for key in rulebook:
        if to_snake_case(key) == snake_name:
            return rulebook[key].get('data', [])

    return []


def discover_primary_key(rulebook: dict, entity_name: str) -> str:
    """
    Discover the primary key for an entity.
    Returns the first non-nullable field, or first field ending in 'Id'.
    """
    schema = get_entity_schema(rulebook, entity_name)

    # First try: find first non-nullable field
    for field in schema:
        if field.get('nullable') == False:
            return to_snake_case(field['name'])

    # Second try: find first field ending in 'Id'
    for field in schema:
        if field['name'].endswith('Id'):
            return to_snake_case(field['name'])

    # Fallback: first field
    if schema:
        return to_snake_case(schema[0]['name'])

    return None


def discover_computed_columns(rulebook: dict, entity_name: str) -> list:
    """
    Discover computed columns for an entity.
    Returns list of snake_case column names where type == "calculated".
    """
    schema = get_entity_schema(rulebook, entity_name)

    computed = []
    for field in schema:
        if field.get('type') == 'calculated':
            computed.append(to_snake_case(field['name']))

    return computed


def get_calculated_fields(schema: list) -> list:
    """
    Extract all calculated fields from a schema.
    Returns list of field dicts where type == "calculated" and formula exists.
    """
    return [
        field for field in schema
        if field.get('type') == 'calculated' and field.get('formula')
    ]


def get_raw_fields(schema: list) -> list:
    """Extract all raw fields from a schema."""
    return [field for field in schema if field.get('type') == 'raw']
